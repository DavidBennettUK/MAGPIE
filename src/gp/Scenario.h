#ifndef SCENARIO_H
#define SCENARIO_H

#include <QObject>
#include <QVector>
#include <QMap>
#include <QSharedPointer>
#include "../gp/Node.h"
#include "../gp/Individual.h"
#include "../gp/TreeFactory.h"
#include "../gp/Generation.h"
#include "../gp/Selection.h"
#include "../gp/Mutation.h"
#include "../gp/Crossover.h"
#include "Parameter.h"

/**
 * Base class for scenarios to perform GP runs.
 * Contains {@link Generation}s of {@link Individual}s.
 * Extend this to create concrete scenarios.
 * @author David Bennett
 */
class Scenario : public QObject
{
    Q_OBJECT

public:
    /** Represents the state of a GP run. */
    enum State
    {
        PAUSED, /**< When the scenario is not running. */
        PAUSING, /**< When a pause request has been made. */
        RUNNING /**< When the scenario is running. */
    };

    /**
     * Constructs the scenario with a population size.
     * Generations will be filled with individuals until the population size.
     * Defaults:
     * Selection: tournament (size: 5)
     * Max tree depth: 5
     * Max generations: 500
     * Target fitness: 100
     * Crossover: subtree
     * Mutation: point
     * Crossover rate: 0.75
     * Mutation rate: 0.15
     * Elitism: off
     * is reached.
     * @param populationSize The population size.
     */
    Scenario(int populationSize);

    /**
     * Destructs the scenario.
     * Destroys all {@link Individual}s and {@link Generation}s generated by this scenario.
     */
    virtual ~Scenario();

    /**
     * Generates a random in based on scenario parameters.
     * Needs to be implemented in concrete scenario to generate concrete {@link Individual}s.
     * @return A pointer to an {@link Individual}, caller takes responsibility for deletion.
     */
    virtual Individual *randomIndividual() const = 0;

    /**
     * Creates an {@link Individual} with the given program tree.
     * The terminal and functional sets must contain the nodes referenced in the string.
     * Needs to be implemented in concrete scenario to generate concrete {@link Individual}s.
     * @see Node#toString()
     * @param tree Program tree in LISP-like syntax.
     * @return A pointer to an {@link Individual}, caller takes responsibility for deletion.
     */
    virtual Individual *createIndividual(const QString tree) const = 0;

    /**
     * Initialises a random population of <code>populationSize</code>.
     * @see Scenario#randomIndividual()
     */
    void initialiseRandomPopulation();

    /** Generate the next {@link Generation}. The previous population is deleted. */
    void nextGeneration();

    /** Reset the scenario, deleting all {@link Individual}s and {@link Generation}s. */
    void reset();

    /**
     * Gets the current generation.
     * @return A pointer to the current {@link Generation}.
     */
    Generation *getCurrentGeneration() const { return currentGeneration; }

    /**
     * Sets the initial {@link Generation}.
     * Resets the generation number to 0.
     * @param generation The {@link Generation} to set the current to.
     */
    void setInitialGeneration(Generation *generation);

    /** Gets the tree builder for this scenario. */
    TreeFactory *getTreeBuilder() const { return treeFactory; }

    /**
     * Gets the target fitness - when an individual with this fitness value is
     * found, the run will terminate.
    */
    int getTargetFitness() const { return targetFitness; }

    /**
     * Sets the target fitness.
     * @param targetFitness When an individual is found with this fitenss value, the run will end.
     */
    void setTargetFitness(const int targetFitness) { this->targetFitness = targetFitness; }

    /** Gets the number of the current {@link Generation}. Initial generation is 0. */
    int getGenerationNumber() const { return generationNumber; }

    /**
     * Get the maximum number of {@link Generation}s this scenario can generate.
     * @return The maximum number of {@link Generation}s.
     */
    int getMaximumGenerations() const { return maxGenerations; }

    /**
     * Sets the maximum number of {@link Generation}s this scenario can generate.
     * @param maxGenerations The maximum number of {@link Generation}s.
     */
    void setMaximumGenerations(const int maxGenerations);

    /**
     * Gets the mutation rate of the scenario.
     * @return The mutation rate, in the range of [0.0,1.0].
     */
    float getMutationRate() const { return mutationRate; }

    /**
     * Sets the mutation rate of the scenario.
     * Mutation rate + crossover rate must not exceed 1.
     * @param mutationRate The mutation rate, in the range of [0.0,1.0].
     */
    void setMutationRate(const float mutationRate) { this->mutationRate = mutationRate; }

    /**
     * Gets the crossover rate of the scenario.
     * Mutation rate + crossover rate must not exceed 1.
     * @return The crossover rate. in the range of [0.0,1.0].
     */
    float getCrossoverRate() const { return crossoverRate; }

    /**
     * Sets the crossover rate of the scenario.
     * @param crossoverRate The crossover rate, in the range of [0.0,1.0].
     */
    void setCrossoverRate(const float crossoverRate) { this->crossoverRate = crossoverRate; }

    /**
     * Get the population size of the scenario.
     * @return The population size of the scenario.
     */
    int getPopulationSize() const { return populationSize; }

    /**
     * Set the population size of the scenario.
     * This will only apply to new generations, call before generating the initial population.
     * Population size must be greater than 1.
     * @param populationSize The population size of the individual.
     */
    void setPopulationSize(const int populationSize) { Q_ASSERT(populationSize > 1); this->populationSize = populationSize; }

    /**
     * Get the selection method used by the scenario.
     * @return The selection method used by the scenario.
     */
    Selection *getSelection() const { return selection; }

    /**
     * Set the selection method for the scenario.
     * The {@link Selection} instance will be deleted with the scenario.
     * @param selection The selection method for the scenario.
     */
    void setSelection(Selection *selection);

    /**
     * @return True if elitism is enabled, otherwise false.
     */
    bool getElitism() const { return elitism; }

    /**
     * Enable or disable elitism.
     * @param enabled True to enable, false to disable.
     */
    void setElitism(bool enabled) { this->elitism = enabled; }

    /**
     * Gets the current state of the GP run.
     * @return The current state of the GP run.
     * @see Scenario#State
     */
    State getState() const { return state; }

    /**
     * Returns the scenario parameters.
     * @return A map of parameter names to parameters.
     */
    QMap<QString,IParameter *> getParameters() const { return parameters; }

public slots:
    /**
     * Starts the GP run.
     * Will continute until a perfect solution is found, or the maximum number of
     * generations is reached.
     */
    void run();

    /**
     * Starts the GP run.
     * Will continue until the maximum number of generations is reached, even if
     * a perfect solution is found.
     * @see Scenario#run()
     */
    void fullRun();

    /**
     * Request the run to be paused.
     * The run will pause when the current generation is complete.
     */
    void pauseRun();

signals:
    /**
     * Emitted when a {@link Generation} is complete.
     * @param generation A copy of the current {@link Generation}.
     * @param number The generation number. See {@link Scenario#getGenerationNumber()}.
     */
    void generationComplete(QSharedPointer<Generation> generation, int number); // TODO returns a clone, could degrade performance - this is due to not being thread safe

    /**
     * Emitted when the run has stopped.
     * Called in cases such as when {@link Scenario#pauseRun()} called, a perfect
     * solution is found or when the maximum number of generations in reached.
     */
    void runFinished();

    /** Emitted when a the scenario is reset. */
    void newRun();

    /**
     * Emitted when the maximum number of generations is changed.
     * @see Scenario#setMaximumGenerations(const int)
     */
    void maxGenerationsChanged(int);

    /** Emitted when a run has started. */
    void runStarted();

protected:
    QMap<QString,IParameter *> parameters; /**< The scenario parameters. */
    Generation *currentGeneration; /**< The current generation. */
    QVector<CreateNode> functionSet; /**< The set of functional nodes {@link Individual}s may use. */
    QVector<CreateNode> terminalSet; /**< The set of terminal nodes {@link Individual}s may use. */
    TreeFactory *treeFactory; /**< The tree factory to create {@link Individual}s with. */
    Mutation *mutation; /**< The mutation method to use. */
    Crossover *crossover; /**< The crossover method to use. */
    Selection *selection; /**< The selection method to use. */
    int targetFitness; /**< The desired fitness. The run will terminate when found. */
    int maxGenerations; /**< The maximum number of generations runs can go up to. */
    int populationSize; /**< The number of {@link Individual}s in each {@link Generation}. */
    int generationNumber; /**< The current generation number, starting from 0 for the initial. */
    float crossoverRate; /**< The crossover rate. */
    float mutationRate; /**< The mutation rate. */
    bool elitism; /**< True if elitism is to be used. */
    State state; /**< The state of the GP run. */
};

#endif // SCENARIO_H
